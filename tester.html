<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ETF Strategy Tester</title>

  <!-- Chart.js core + date‑fns adapter for time‑axis -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

  <style>
    body {font-family: Arial, Helvetica, sans-serif; margin: 0; padding: 2rem; background:#f5f7fa; color:#222}
    h1   {margin-bottom: .25rem}
    .controls {display:flex; flex-wrap:wrap; gap:1rem; align-items:center}
    label {font-size:.9rem; margin-right:.25rem}
    button{background:#0066ff; color:#fff; border:none; padding:.5rem 1rem; border-radius:4px; cursor:pointer}
    button:hover{background:#004fcc}
    .stats {margin-top:1rem; font-size:.95rem}
    .chart-wrapper{max-width:1000px; height:400px; margin-top:2rem}
    
    /* Add this to your existing style section */
    .trade-log {
      margin-top: 2rem;
      max-width: 1000px;
    }
    .trade-log-container {
      max-height: 500px;
      overflow-y: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
    }
    .trade-entry {
      padding: 1rem;
      border-bottom: 1px solid #eee;
    }
    .trade-entry:last-child {
      border-bottom: none;
    }
    .trade-date {
      font-weight: bold;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #333;
    }
    .risk-status {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      background: #f5f5f5;
    }
    .transaction-header {
      font-weight: bold;
      margin-top: 0.5rem;
      margin-bottom: 0.25rem;
      color: #666;
      font-size: 0.9rem;
    }
    .transaction, .allocation {
      margin-left: 1rem;
      font-size: 0.9rem;
      line-height: 1.4;
    }
    .sell-transactions .transaction {
      color: #d32f2f;
    }
    .buy-transactions .transaction {
      color: #388e3c;
    }
    .no-trades, .loading {
      padding: 1rem;
      color: #666;
      font-style: italic;
    }
    /* Add to your existing style section */
    .initial-allocation {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
      background: #e3f2fd;
      color: #0d47a1;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>ETF Strategy Tester</h1>
  <div class="controls">
    <div>
      <label for="strategySelect">Strategy:</label>
      <select id="strategySelect">
        <option value="dmr">1 – Dual Momentum Rotation</option>
        <option value="barbell">2 – Leveraged 60/40 Barbell Trend</option>
        <option value="trend">2.1 – Leveraged Trend</option>
        <option value="turbo">3 – Turbo Triple‑Momentum Stack</option>
      </select>
    </div>
    <div>
      <label for="startDate">Start:</label>
      <input type="date" id="startDate" value="1993-01-29" />
    </div>
    <div>
      <label for="endDate">End:</label>
      <input type="date" id="endDate" />
    </div>
    <div>
      <label for="executionToggle">Execution:</label>
      <select id="executionToggle">
        <option value="close">Signal & Execute at Close</option>
        <option value="open">Signal & Execute at Open</option>
      </select>
    </div>
    <button id="runBtn">Run Test</button>
  </div>

  <div class="stats" id="stats"></div>
  <div class="chart-wrapper"><canvas id="equityChart"></canvas></div>
  
  <!-- Add this right after the chart div -->
  <div id="tradeLog" class="trade-log">
    <h2>Trade Log</h2>
    <div class="no-trades">Run a test to see trade details</div>
  </div>

<script>
// ---------------- Utility helpers ----------------------------------
function csvToSeries(csv){
  const lines = csv.trim().split(/\n+/);
  const out = [];
  for(let i=1;i<lines.length;i++){
    const [d,o,h,l,c,v] = lines[i].split(',');
    const price = +c, open = +o, vol = +v;
    if(!isFinite(price)) continue;
    out.push({date:new Date(d), open:open, close:price, vol:isFinite(vol)?vol:0});
  }
  return out.reverse(); // earliest first
}

// Add these utility functions for trade logging
function formatDate(date) {
  return date.toISOString().split('T')[0];
}

function formatCurrency(amount) {
  return '$' + amount.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
}

function formatPercent(value) {
  return (value * 100).toFixed(2) + '%';
}

async function fetchTicker(tk){
  const r = await fetch(`proxy.php?symbol=${tk}.us`);
  if(!r.ok) throw new Error('fetch ' + tk);
  return csvToSeries(await r.text());
}

// Replace the fetchTickerWithRetry function with this updated version
async function fetchTickerWithRetry(tk, maxRetries = 3, delay = 1000) {
  let retries = 0;
  
  while (retries < maxRetries) {
    try {
      // Add delay between requests
      if (retries > 0) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      
      // Modified to fetch more historical data than needed to ensure enough for indicators
      const r = await fetch(`proxy.php?symbol=${tk}.us`);
      if (!r.ok) {
        if (r.status === 502) {
          console.warn(`Rate limited for ${tk}, retrying in ${delay}ms...`);
          retries++;
          continue;
        }
        throw new Error('fetch ' + tk);
      }
      return csvToSeries(await r.text());
    } catch (err) {
      retries++;
      if (retries >= maxRetries) throw err;
    }
  }
}

function sma(arr, i, len){
  if(i < len-1) return null;
  let s=0;
  for(let k=i-len+1;k<=i;k++) s += arr[k].close;
  return s/len;
}
function computeRSI(arr, len=14){
  const res = new Array(arr.length).fill(null);
  let g=0,l=0;
  for(let i=1;i<len;i++){
    const diff = arr[i].close - arr[i-1].close;
    if(diff>=0) g += diff; else l -= diff;
  }
  for(let i=len;i<arr.length;i++){
    const diff = arr[i].close - arr[i-1].close;
    if(diff>=0){ g = (g*(len-1)+diff)/len; l = (l*(len-1))/len; }
    else       { g = (g*(len-1))/len;       l = (l*(len-1)-diff)/len; }
    const rs = l===0 ? 100 : g/l;
    res[i] = 100 - 100/(1+rs);
  }
  return res;
}
function sliceByDate(arr, s, e){ return arr.filter(p=>p.date>=s && p.date<=e); }
function alignSeries(obj){
  const keys = Object.keys(obj);
  const dateSets = keys.map(k=> new Set(obj[k].map(p=>+p.date)));
  const common = [...dateSets.reduce((a,s)=>new Set([...a].filter(x=>s.has(x))))].sort((a,b)=>a-b);
  const aligned = {};
  keys.forEach(k=>{
    const m = new Map(obj[k].map(p=>[+p.date,p]));
    aligned[k] = common.map(ts=>m.get(ts));
  });
  return {dates:common.map(ts=>new Date(+ts)), series:aligned};
}
function calcCAGR(values, days){ const yrs = days/252; return Math.pow(values[values.length-1]/values[0], 1/yrs)-1; }
function calcMaxDD(vals){ let peak=vals[0], dd=0; for(const v of vals){ if(v>peak) peak=v; dd=Math.min(dd,(v-peak)/peak);} return dd; }
function avgDollarVol(arr, i, len=20){ if(i<len-1) return 0; let sum=0,count=0; for(let k=i-len+1;k<=i;k++){ const p=arr[k]; if(!p) continue; if(isFinite(p.close)&&isFinite(p.vol)){ sum += p.close*p.vol; count++; }} return count?sum/len:0; }

// ---------------- Strategy engines --------------------------------
function runDMR(aligned, userStartIndex = 0){
  const {dates, series} = aligned;
  const risk = ['spy','qqq','iwm'];
  const def  = ['tlt','gld','shy'];
  const perfW=21, smaL=200;
  
  // Get execution mode from toggle
  const executionMode = document.getElementById('executionToggle').value;
  
  // Initialize equity array
  const eq = [];
  eq[userStartIndex] = 100;
  
  // Create trade log array
  const tradeLog = [];
  let currentAllocation = {};
  let initialAllocationDone = false;
  
  // Calculate full equity curve but only start from userStartIndex
  for(let i=1; i<dates.length; i++){
    if(i <= userStartIndex) {
      eq[i] = 100; // Initialize early values to 100
      continue;
    }
    
    // For days before we have enough history for indicators, just copy previous equity value
    if(i-userStartIndex < Math.max(perfW, smaL)){ 
      eq[i] = eq[i-1]; 
      continue; 
    }
    
    // Choose which price to use for execution
    const priceKey = executionMode === 'close' ? 'close' : 'open';
    
    // Calculate momentum using close prices (standard)
    const ranks = risk.slice().sort((a,b) => 
      series[b][i].close/series[b][i-perfW].close - series[a][i].close/series[a][i-perfW].close
    );
    
    // Calculate SMAs using close prices (standard)
    const active = ranks.filter(tk => series[tk][i][priceKey] > sma(series[tk], i, smaL));
    const longs = (active.length ? active : def).slice(0,2);
    const w = 1/longs.length;
    
    // Create new allocation
    const newAllocation = {};
    longs.forEach(tk => newAllocation[tk] = w);
    
    // Handle initial allocation
    if (!initialAllocationDone && i-userStartIndex >= Math.max(perfW,smaL)) {
      initialAllocationDone = true;
      
      // Create initial trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        executionType: executionMode === 'close' ? "Close" : "Open",
        isInitial: true
      };
      
      // Record initial buys
      longs.forEach(tk => {
        const buyAmount = eq[i-1] * w;
        const price = series[tk][i][priceKey];
        entry.buys.push({
          ticker: tk,
          price: price.toFixed(2),
          amount: formatCurrency(buyAmount),
          shares: (buyAmount / price).toFixed(2)
        });
        
        // Add to new allocation
        entry.newAllocation[tk] = {
          weight: formatPercent(w),
          value: formatCurrency(eq[i-1] * w),
          price: price.toFixed(2)
        };
      });
      
      tradeLog.push(entry);
    }
    // Compare current and new allocations for rebalances
    else if (i > Math.max(perfW,smaL) && !compareAllocations(currentAllocation, newAllocation)) {
      // Portfolio value before rebalance
      const portfolioValue = eq[i-1];
      
      // Create trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        executionType: executionMode === 'close' ? "Close" : "Open"
      };
      
      // Record sells
      Object.keys(currentAllocation).forEach(tk => {
        if (!newAllocation[tk] || newAllocation[tk] < currentAllocation[tk]) {
          const sellAmount = portfolioValue * (newAllocation[tk] || 0) - portfolioValue * currentAllocation[tk];
          const price = series[tk][i][priceKey];
          entry.sells.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(Math.abs(sellAmount)),
            shares: Math.abs(sellAmount / price).toFixed(2)
          });
        }
      });
      
      // Record buys
      Object.keys(newAllocation).forEach(tk => {
        if (!currentAllocation[tk] || newAllocation[tk] > currentAllocation[tk]) {
          const buyAmount = portfolioValue * newAllocation[tk] - portfolioValue * (currentAllocation[tk] || 0);
          const price = series[tk][i][priceKey];
          entry.buys.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(buyAmount),
            shares: (buyAmount / price).toFixed(2)
          });
        }
      });
      
      // Record new allocation
      longs.forEach(tk => {
        const price = series[tk][i][priceKey];
        entry.newAllocation[tk] = {
          weight: formatPercent(w),
          value: formatCurrency(portfolioValue * w),
          price: price.toFixed(2)
        };
      });
      
      tradeLog.push(entry);
    }
    
    currentAllocation = {...newAllocation};
    
    // Calculate returns based on execution mode
    let ret = 0;
    if (executionMode === 'close') {
      // For close execution, use close-to-close returns
      longs.forEach(tk => {
        ret += w * (series[tk][i].close / series[tk][i-1].close - 1);
      });
    } else {
      // For open execution, use open-to-open returns
      if (i > 1) {
        longs.forEach(tk => {
          ret += w * (series[tk][i].open / series[tk][i-1].open - 1);
        });
      } else {
        // For the first day, use previous close to current open
        longs.forEach(tk => {
          ret += w * (series[tk][i].open / series[tk][i-1].close - 1);
        });
      }
    }
    
    eq[i] = eq[i-1] * (1 + ret);
  }
  
  return {dates, equity:eq, tradeLog};
}

function runBarbell(aligned, userStartIndex = 0){
  const {dates, series} = aligned;
  const spyRSI = computeRSI(series['spy']);
  const smaL=100;
  
  // Get execution mode from toggle
  const executionMode = document.getElementById('executionToggle').value;
  
  // Initialize equity array
  const eq = [];
  eq[userStartIndex] = 100;
  
  // Create trade log array
  const tradeLog = [];
  let currentAllocation = {};
  let initialAllocationDone = false;
  
  // Calculate full equity curve but only start from userStartIndex
  for(let i=1; i<dates.length; i++){
    if(i <= userStartIndex) {
      eq[i] = 100; // Initialize early values to 100
      continue;
    }
    
    // For days before we have enough history for indicators, just copy previous equity value
    if(i < smaL || spyRSI[i] === null){ 
      eq[i] = eq[i-1]; 
      continue; 
    }
    
    // Choose which price to use for signal generation and execution
    const priceKey = executionMode === 'close' ? 'close' : 'open';
    
    // Use standard SMA calculation based on close prices
    const spySMA = sma(series['spy'], i, smaL);
    const tltSMA = sma(series['tlt'], i, smaL);
    
    // But compare against current day's open or close price based on execution mode
    const spyPrice = series['spy'][i][priceKey];
    const tltPrice = series['tlt'][i][priceKey];
    
    // Calculate the allocation
    const weights = {};
    
    if(spyPrice < spySMA || spyRSI[i] < 40){ 
      weights['upro'] = 0.30; 
      weights['splv'] = 0.30; 
    } else { 
      weights['upro'] = 0.60; 
    }
    
    if(tltPrice < tltSMA){ 
      weights['shy'] = 0.40; 
    } else { 
      weights['tmf'] = 0.40; 
    }
    
    // Handle initial allocation
    if (!initialAllocationDone && i >= smaL) {
      initialAllocationDone = true;
      
      // Create initial trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        executionType: executionMode === 'close' ? "Close" : "Open",
        isInitial: true
      };
      
      // Record initial buys at current price
      Object.keys(weights).forEach(tk => {
        const buyAmount = eq[i-1] * weights[tk];
        const price = series[tk][i][priceKey];
        entry.buys.push({
          ticker: tk,
          price: price.toFixed(2),
          amount: formatCurrency(buyAmount),
          shares: (buyAmount / price).toFixed(2)
        });
        
        // Add to new allocation
        entry.newAllocation[tk] = {
          weight: formatPercent(weights[tk]),
          value: formatCurrency(eq[i-1] * weights[tk]),
          price: price.toFixed(2)
        };
      });
      
      tradeLog.push(entry);
      currentAllocation = {...weights};
    }
    // Check if allocation changed for rebalances
    else if (i > smaL && !compareAllocations(currentAllocation, weights)) {
      // Portfolio value before rebalance
      const portfolioValue = eq[i-1];
      
      // Create trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        executionType: executionMode === 'close' ? "Close" : "Open"
      };
      
      // Record sells at current price
      Object.keys(currentAllocation).forEach(tk => {
        if (!weights[tk] || weights[tk] < currentAllocation[tk]) {
          const sellAmount = portfolioValue * (weights[tk] || 0) - portfolioValue * currentAllocation[tk];
          const price = series[tk][i][priceKey];
          entry.sells.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(Math.abs(sellAmount)),
            shares: Math.abs(sellAmount / price).toFixed(2)
          });
        }
      });
      
      // Record buys at current price
      Object.keys(weights).forEach(tk => {
        if (!currentAllocation[tk] || weights[tk] > currentAllocation[tk]) {
          const buyAmount = portfolioValue * weights[tk] - portfolioValue * (currentAllocation[tk] || 0);
          const price = series[tk][i][priceKey];
          entry.buys.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(buyAmount),
            shares: (buyAmount / price).toFixed(2)
          });
        }
      });
      
      // Record new allocation
      Object.keys(weights).forEach(tk => {
        const price = series[tk][i][priceKey];
        entry.newAllocation[tk] = {
          weight: formatPercent(weights[tk]),
          value: formatCurrency(portfolioValue * weights[tk]),
          price: price.toFixed(2)
        };
      });
      
      tradeLog.push(entry);
      currentAllocation = {...weights};
    }
    
    // Calculate returns based on execution mode
    let ret = 0;
    if (executionMode === 'close') {
      // For close execution, use close-to-close returns
      Object.keys(currentAllocation).forEach(tk => {
        ret += currentAllocation[tk] * (series[tk][i].close / series[tk][i-1].close - 1);
      });
    } else {
      // For open execution, use open-to-open returns
      if (i > 1) {
        Object.keys(currentAllocation).forEach(tk => {
          ret += currentAllocation[tk] * (series[tk][i].open / series[tk][i-1].open - 1);
        });
      } else {
        // For the first day, use previous close to current open
        Object.keys(currentAllocation).forEach(tk => {
          ret += currentAllocation[tk] * (series[tk][i].open / series[tk][i-1].close - 1);
        });
      }
    }
    
    eq[i] = eq[i-1] * (1 + ret);
  }
  
  return {dates, equity:eq, tradeLog};
}

function runLeveragedTrend(aligned, userStartIndex = 0){
  const {dates, series} = aligned;
  const spyRSI = computeRSI(series['spy']);
  const smaL = 100;
  
  // Get execution mode from toggle
  const executionMode = document.getElementById('executionToggle').value;
  
  // Initialize equity array
  const eq = [];
  eq[userStartIndex] = 100;
  
  // Create trade log array
  const tradeLog = [];
  let currentAllocation = {};
  let initialAllocationDone = false;
  
  // Calculate full equity curve but only start from userStartIndex
  for(let i=1; i<dates.length; i++){
    if(i <= userStartIndex) {
      eq[i] = 100; // Initialize early values to 100
      continue;
    }
    
    // For days before we have enough history for indicators, just copy previous equity value
    if(i < smaL || spyRSI[i] === null){ 
      eq[i] = eq[i-1]; 
      continue; 
    }
    
    // Choose which price to use for execution
    const priceKey = executionMode === 'close' ? 'close' : 'open';
    
    // Calculate SMA using close prices (standard)
    const spySMA = sma(series['spy'], i, smaL);
    
    // But compare against current day's open or close price based on execution mode
    const spyPrice = series['spy'][i][priceKey];
    
    // Calculate allocation
    const weights = {};
    if(spyPrice < spySMA || spyRSI[i] < 40){ 
      weights['upro'] = 0; 
    } else { 
      weights['upro'] = 1; 
    }
    
    // Handle initial allocation
    if (!initialAllocationDone && i >= smaL) {
      initialAllocationDone = true;
      
      // Create initial trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        executionType: executionMode === 'close' ? "Close" : "Open",
        isInitial: true
      };
      
      // Record initial buys
      Object.keys(weights).forEach(tk => {
        if (weights[tk] > 0) {
          const buyAmount = eq[i-1] * weights[tk];
          const price = series[tk][i][priceKey];
          entry.buys.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(buyAmount),
            shares: (buyAmount / price).toFixed(2)
          });
          
          // Add to new allocation
          entry.newAllocation[tk] = {
            weight: formatPercent(weights[tk]),
            value: formatCurrency(eq[i-1] * weights[tk]),
            price: price.toFixed(2)
          };
        }
      });
      
      tradeLog.push(entry);
    }
    // Check if allocation changed for rebalances
    else if (i > smaL && !compareAllocations(currentAllocation, weights)) {
      // Portfolio value before rebalance
      const portfolioValue = eq[i-1];
      
      // Create trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        executionType: executionMode === 'close' ? "Close" : "Open"
      };
      
      // Record sells
      Object.keys(currentAllocation).forEach(tk => {
        if (!weights[tk] || weights[tk] < currentAllocation[tk]) {
          const sellAmount = portfolioValue * (weights[tk] || 0) - portfolioValue * currentAllocation[tk];
          const price = series[tk][i][priceKey];
          entry.sells.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(Math.abs(sellAmount)),
            shares: Math.abs(sellAmount / price).toFixed(2)
          });
        }
      });
      
      // Record buys
      Object.keys(weights).forEach(tk => {
        if (weights[tk] > 0 && (!currentAllocation[tk] || weights[tk] > currentAllocation[tk])) {
          const buyAmount = portfolioValue * weights[tk] - portfolioValue * (currentAllocation[tk] || 0);
          const price = series[tk][i][priceKey];
          entry.buys.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(buyAmount),
            shares: (buyAmount / price).toFixed(2)
          });
        }
      });
      
      // Record new allocation
      Object.keys(weights).forEach(tk => {
        if (weights[tk] > 0) {
          const price = series[tk][i][priceKey];
          entry.newAllocation[tk] = {
            weight: formatPercent(weights[tk]),
            value: formatCurrency(portfolioValue * weights[tk]),
            price: price.toFixed(2)
          };
        }
      });
      
      tradeLog.push(entry);
    }
    
    // Calculate returns based on execution mode
    let ret = 0;
    if (executionMode === 'close') {
      // For close execution, use close-to-close returns
      Object.keys(weights).forEach(tk => {
        ret += weights[tk] * (series[tk][i].close / series[tk][i-1].close - 1);
      });
    } else {
      // For open execution, use open-to-open returns
      if (i > 1) {
        Object.keys(weights).forEach(tk => {
          ret += weights[tk] * (series[tk][i].open / series[tk][i-1].open - 1);
        });
      } else {
        // For the first day, use previous close to current open
        Object.keys(weights).forEach(tk => {
          ret += weights[tk] * (series[tk][i].open / series[tk][i-1].close - 1);
        });
      }
    }
    
    eq[i] = eq[i-1] * (1 + ret);
  }
  
  return {dates, equity:eq, tradeLog};
}

function runTurbo(aligned, userStartIndex = 0){
  const {dates, series} = aligned;
  const universe = Object.keys(series).filter(tk => !['spy','tlt','tmf','shy'].includes(tk));
  const spy = series['spy']; 
  const spyRSI = computeRSI(spy);
  const smaL = 200, perfW = 21, liqThresh = 5e6;
  
  // Get execution mode from toggle
  const executionMode = document.getElementById('executionToggle').value;
  
  // Initialize equity array
  const eq = [];
  eq[userStartIndex] = 100;
  
  // Create trade log array
  const tradeLog = [];
  let currentAllocation = {};
  let initialAllocationDone = false;

  // Calculate full equity curve but only start from userStartIndex
  for(let i=1; i<dates.length; i++){
    if(i <= userStartIndex) {
      eq[i] = 100; // Initialize early values to 100
      continue;
    }
    
    // For days before we have enough history for indicators, just copy previous equity value
    if(i < Math.max(smaL, perfW)){ 
      eq[i] = eq[i-1]; 
      continue; 
    }
    
    // Choose which price to use for execution
    const priceKey = executionMode === 'close' ? 'close' : 'open';
    
    // Use standard SMA calculation based on close prices
    const spySMA = sma(spy, i, smaL);
    
    // But compare against current day's open or close price based on execution mode
    const spyPrice = spy[i][priceKey];
    
    let riskOn = spyPrice > spySMA && spyRSI[i] >= 45;

    // liquid tradables
    let tradables = universe.filter(tk => series[tk] && series[tk][i]);
    tradables = tradables.filter(tk => avgDollarVol(series[tk], i, 20) > liqThresh);

    // Sort by momentum using closing prices (standard)
    tradables.sort((a,b) => 
      series[b][i].close/series[b][i-perfW].close - series[a][i].close/series[a][i-perfW].close
    );

    if(riskOn && tradables.length < 2) riskOn = false; // no liquid names => risk off

    let longs;
    if(riskOn){ 
      longs = tradables.slice(0,2); 
    } else { 
      longs = ['tmf','shy']; 
    }

    const w = 1/longs.length;
    
    // Create new allocation
    const newAllocation = {};
    longs.forEach(tk => newAllocation[tk] = w);
    
    // Handle initial allocation
    if (!initialAllocationDone && i >= Math.max(smaL, perfW)) {
      initialAllocationDone = true;
      
      // Create initial trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        riskOn: riskOn,
        executionType: executionMode === 'close' ? "Close" : "Open",
        isInitial: true
      };
      
      // Record initial buys
      longs.forEach(tk => {
        const buyAmount = eq[i-1] * w;
        const price = series[tk][i][priceKey];
        entry.buys.push({
          ticker: tk,
          price: price.toFixed(2),
          amount: formatCurrency(buyAmount),
          shares: (buyAmount / price).toFixed(2)
        });
        
        // Add to new allocation
        entry.newAllocation[tk] = {
          weight: formatPercent(w),
          value: formatCurrency(eq[i-1] * w),
          price: price.toFixed(2)
        };
      });
      
      tradeLog.push(entry);
    }
    // Check if allocation changed for rebalances
    else if (i > Math.max(smaL, perfW) && !compareAllocations(currentAllocation, newAllocation)) {
      // Portfolio value before rebalance
      const portfolioValue = eq[i-1];
      
      // Create trade log entry
      const entry = {
        date: formatDate(dates[i]),
        sells: [],
        buys: [],
        newAllocation: {},
        riskOn: riskOn,
        executionType: executionMode === 'close' ? "Close" : "Open"
      };
      
      // Record sells
      Object.keys(currentAllocation).forEach(tk => {
        if (!newAllocation[tk] || newAllocation[tk] < currentAllocation[tk]) {
          const sellAmount = portfolioValue * (newAllocation[tk] || 0) - portfolioValue * currentAllocation[tk];
          const price = series[tk][i][priceKey];
          entry.sells.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(Math.abs(sellAmount)),
            shares: Math.abs(sellAmount / price).toFixed(2)
          });
        }
      });
      
      // Record buys
      Object.keys(newAllocation).forEach(tk => {
        if (!currentAllocation[tk] || newAllocation[tk] > currentAllocation[tk]) {
          const buyAmount = portfolioValue * newAllocation[tk] - portfolioValue * (currentAllocation[tk] || 0);
          const price = series[tk][i][priceKey];
          entry.buys.push({
            ticker: tk,
            price: price.toFixed(2),
            amount: formatCurrency(buyAmount),
            shares: (buyAmount / price).toFixed(2)
          });
        }
      });
      
      // Record new allocation
      longs.forEach(tk => {
        const price = series[tk][i][priceKey];
        entry.newAllocation[tk] = {
          weight: formatPercent(w),
          value: formatCurrency(portfolioValue * w),
          price: price.toFixed(2)
        };
      });
      
      tradeLog.push(entry);
    }
    
    currentAllocation = {...newAllocation};
    
    // Calculate returns based on execution mode
    let ret = 0;
    if (executionMode === 'close') {
      // For close execution, use close-to-close returns
      longs.forEach(tk => {
        ret += w * (series[tk][i].close / series[tk][i-1].close - 1);
      });
    } else {
      // For open execution, use open-to-open returns
      if (i > 1) {
        longs.forEach(tk => {
          ret += w * (series[tk][i].open / series[tk][i-1].open - 1);
        });
      } else {
        // For the first day, use previous close to current open
        longs.forEach(tk => {
          ret += w * (series[tk][i].open / series[tk][i-1].close - 1);
        });
      }
    }
    
    eq[i] = eq[i-1] * (1 + ret);
  }
  
  return {dates, equity:eq, tradeLog};
}

// Helper function to compare allocations
function compareAllocations(a, b) {
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  
  if (keysA.length !== keysB.length) return false;
  
  for (const key of keysA) {
    if (!b.hasOwnProperty(key) || Math.abs(a[key] - b[key]) > 0.001) return false;
  }
  
  return true;
}

// ---------------- Main run routine --------------------------------
async function runTest(){
  const strat = document.getElementById('strategySelect').value;
  const startDate = new Date(document.getElementById('startDate').value);
  const endInput = document.getElementById('endDate').value;
  const endDate = endInput ? new Date(endInput) : new Date();

  // Define lookback periods for each strategy
  const lookbackPeriods = {
    'dmr': 200,     // Maximum of SMA200 and 21-day momentum window
    'barbell': 100, // SMA100 for barbell
    'trend': 100,   // SMA100 for leveraged trend
    'turbo': 200    // Maximum of SMA200 and 21-day momentum window
  };
  
  // Calculate the fetch start date (earlier than user's start date)
  const lookbackDays = lookbackPeriods[strat];
  const fetchStartDate = new Date(startDate);
  // Move back by approximately lookbackDays trading days (multiply by 1.4 to account for weekends/holidays)
  fetchStartDate.setDate(fetchStartDate.getDate() - Math.ceil(lookbackDays * 1.4));

  const tickersDMR     = ['spy','qqq','iwm','tlt','gld','shy'];
  const tickersBarbell = ['upro','splv','tmf','shy','spy','tlt'];
  const tickersTrend   = ['upro','spy'];
  const tickersTurbo   = ['soxl','tecl','fngu','tqqq','upro','labu','webl','retl','want','dfen','udow','tmf','shy','spy','tlt'];

  let tickers;
  
  switch (strat) {
    case 'dmr':
      tickers = tickersDMR;
      break;
    case 'barbell':
      tickers = tickersBarbell;
      break;
    case 'trend':
      tickers = tickersTrend;
      break;
    case 'turbo':
      tickers = tickersTurbo;
      break;
  }

  // Clear previous trade log if it exists
  document.getElementById('tradeLog').innerHTML = '<h2>Trade Log</h2><div class="loading">Loading...</div>';

  const byTk={};
  // Use sequential fetches with delay to avoid rate limits
  for (const tk of tickers) {
    try {
      // Fetch from our calculated fetch start date, not user's start date
      const fullData = await fetchTickerWithRetry(tk);
      byTk[tk] = sliceByDate(fullData, fetchStartDate, endDate);
      // Add small delay between requests
      await new Promise(resolve => setTimeout(resolve, 300));
    } catch (e) {
      console.error(`Error fetching ${tk}:`, e);
    }
  }

  // Remove very new ETFs with < 250 trading days so they don't shrink the common date set
  if(strat==='turbo'){
    Object.keys(byTk).forEach(tk=>{ if(byTk[tk].length < 250) delete byTk[tk]; });
  }
  
  const aligned = alignSeries(byTk);
  
  // Find the index in aligned.dates that corresponds to the user's start date
  const userStartIndex = aligned.dates.findIndex(date => date >= startDate);
  
  // Pass all data to strategy, but tell it when to start showing results
  let result;
  let label;

  switch (strat) {
    case 'dmr':
      result = runDMR(aligned, userStartIndex);
      label = 'Dual Momentum Rotation';
      break;
    case 'barbell':
      result = runBarbell(aligned, userStartIndex);
      label = 'Barbell';
      break;
    case 'trend':
      result = runLeveragedTrend(aligned, userStartIndex);
      label = 'Leveraged Trend';
      break;
    case 'turbo':
      result = runTurbo(aligned, userStartIndex);
      label = 'Turbo';
      break;
    default:
      throw new Error('Unknown strategy: ' + strat);
  }

  // metrics - only calculate based on visible equity curve
  const days = result.dates.length;
  const cagr = calcCAGR(result.equity, days);
  const maxDD = calcMaxDD(result.equity);
  const dailyRet = []; 
  for(let i=1; i<result.equity.length; i++) dailyRet.push(result.equity[i]/result.equity[i-1]-1);
  const avgRet=dailyRet.reduce((s,r)=>s+r,0)/dailyRet.length;
  const varRet=dailyRet.reduce((s,r)=>s+Math.pow(r-avgRet,2),0)/dailyRet.length;
  const stdDev=Math.sqrt(varRet);
  const negRet=dailyRet.filter(r=>r<0);
  const downVar=negRet.reduce((s,r)=>s+Math.pow(r,2),0)/dailyRet.length;
  const downDev=Math.sqrt(downVar);
  const annRet=cagr;
  const annStd=stdDev*Math.sqrt(252);
  const sharpe=annRet/annStd;
  const sortino=annRet/(downDev*Math.sqrt(252));
  const calmar=annRet/Math.abs(maxDD);

  document.getElementById('stats').innerHTML =
    `<strong>Annualized Return:</strong> ${(annRet*100).toFixed(2)}% &nbsp;|&nbsp; `+
    `<strong>Max Drawdown:</strong> ${(maxDD*100).toFixed(2)}% &nbsp;|&nbsp; `+
    `<strong>Sharpe:</strong> ${sharpe.toFixed(2)} &nbsp;|&nbsp; `+
    `<strong>Sortino:</strong> ${sortino.toFixed(2)} &nbsp;|&nbsp; `+
    `<strong>Calmar:</strong> ${calmar.toFixed(2)}`;

  // chart
  if(window.equityChartInstance) window.equityChartInstance.destroy();
  const ctx=document.getElementById('equityChart').getContext('2d');
  window.equityChartInstance = new Chart(ctx, {
    type:'line',
    data:{
      labels:result.dates,
      datasets:[{
        label,
        data:result.equity,
        borderWidth:1,
        fill:false,
        pointRadius:0
      }]
    },
    options:{ responsive:true, maintainAspectRatio:false, scales:{ x:{ type:'time' }, y:{ type:'linear' } } }
  });
  
  // Render trade log
  renderTradeLog(result.tradeLog);
}

// Function to render the trade log
function renderTradeLog(tradeLog) {
  const tradeLogEl = document.getElementById('tradeLog');
  
  if (!tradeLog || tradeLog.length === 0) {
    tradeLogEl.innerHTML = '<h2>Trade Log</h2><div class="no-trades">No trades in selected period</div>';
    return;
  }
  
  let html = '<h2>Trade Log</h2>';
  html += '<div class="trade-log-container">';
  
  tradeLog.forEach(entry => {
    html += `<div class="trade-entry">`;
    html += `<div class="trade-date">${entry.date}</div>`;
    
    if (entry.isInitial) {
      html += `<div class="initial-allocation">INITIAL ALLOCATION</div>`;
    }
    
    if (entry.hasOwnProperty('riskOn')) {
      html += `<div class="risk-status">Risk ${entry.riskOn ? 'ON' : 'OFF'}</div>`;
    }
    
    if (entry.sells.length > 0) {
      html += `<div class="sell-transactions">`;
      html += `<div class="transaction-header">SELLS</div>`;
      entry.sells.forEach(sell => {
        html += `<div class="transaction">Sell ${sell.shares} shares of ${sell.ticker.toUpperCase()} @ ${sell.price} (${sell.amount})</div>`;
      });
      html += `</div>`;
    }
    
    if (entry.buys.length > 0) {
      html += `<div class="buy-transactions">`;
      html += `<div class="transaction-header">BUYS</div>`;
      entry.buys.forEach(buy => {
        html += `<div class="transaction">Buy ${buy.shares} shares of ${buy.ticker.toUpperCase()} @ ${buy.price} (${buy.amount})</div>`;
      });
      html += `</div>`;
    }
    
    html += `<div class="new-allocation">`;
    html += `<div class="transaction-header">NEW ALLOCATION</div>`;
    Object.keys(entry.newAllocation).forEach(tk => {
      const alloc = entry.newAllocation[tk];
      html += `<div class="allocation">${tk.toUpperCase()}: ${alloc.weight} (${alloc.value}) @ ${alloc.price}</div>`;
    });
    html += `</div>`;
    
    html += `</div>`;
  });
  
  html += '</div>';
  tradeLogEl.innerHTML = html;
}

function toggleLoadingState(isLoading) {
  const chartWrapper = document.querySelector('.chart-wrapper');
  const tradeLogEl = document.getElementById('tradeLog');
  const statsEl = document.getElementById('stats');
  
  if (isLoading) {
    // Hide chart and trade log, show loading message
    chartWrapper.style.display = 'none';
    statsEl.textContent = 'Running…';
    tradeLogEl.innerHTML = '<h2>Trade Log</h2><div class="loading">Loading...</div>';
  } else {
    // Show chart again when done
    chartWrapper.style.display = 'block';
  }
}

// init
document.getElementById('endDate').valueAsDate = new Date();
document.getElementById('runBtn').onclick = () => { 
  toggleLoadingState(true);
  runTest()
    .then(() => toggleLoadingState(false))
    .catch(e => { 
      document.getElementById('stats').textContent = 'Error: ' + e.message; 
      console.error(e);
      toggleLoadingState(false);
    }); 
};
</script>
</body>
</html>
